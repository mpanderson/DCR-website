{% extends "base.html"%}
{% block title%}Distributions{%endblock%}

{% block content %}

<style>
  .distContainer {
      display: flex;
      flex-wrap: wrap;
      height: 800px;
      max-width: 100%;
      position: relative;
    background-color: black;
  }

  .selectContainer {
      width: 15%;
      height: 100%;
      background-color: lightgrey;
      display: flex;
        flex-direction: column; /* Stack items vertically */
        align-items: center; /* Center items horizontally */
     position: absolute;
    padding: 3% 0% 5% 0%;
    box-sizing: border-box;
      
    
  }

  .argsContainer {
      flex-grow: 1;
      height: 22%;
      width: 85%;
      background-color: lightgrey;
   
margin: top; 
      /* margin-left: 15%; */
    top: 0;
    right: 0;
     position: absolute;
    padding: 3% 5% 5% 5%;
    box-sizing: border-box;
  }

  .graphContainer {
      flex-grow: 5;
      background-color: white;
      height: 78%;
      width: 85%;
      bottom: 0;
      right: 0;
      position: absolute;
    padding: 0% 5% 5% 5%;
    box-sizing: border-box;
     
  }
  .innerContainer {
      text-align: center; /* Center the text inside the inner container */
  }

  /* Apply styles to the select element */
  #distributionSelect {
      width: 100%; /* Take up full width of the container */
      font-size: 16px; /* Adjust the font size as needed */
      padding: 10px; /* Add padding for better appearance */
      border: 1px solid #ccc; /* Add a border */
      border-radius: 10px; /* Add rounded corners */
      outline: none; /* Remove the default outline */
  }

  /* Media Queries for Tablet and Mobile */
  @media only screen and (max-width: 768px) {
      .selectContainer,
      .argsContainer,
      .graphContainer {
          width: 100%;
      }
  }
  
</style>


    <main style="font-family: Arial">
       <center> <h2>Distributions</h2></center>

      <p>This page contains tools that help researchers with simple visualizations and calculations </p>

      <h3><p class="separator"><a >Distribution Visualization and Calculation</a></p>
      </h3>
      
      <script src="https://cdn.jsdelivr.net/npm/jstat@1.9.6/dist/jstat.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

      <div class="distContainer">

         <div class="selectContainer">

                  <div style="margin-bottom: 40%;">
                    <table>
                      <tr><td style="border: none; padding: 0px 0px 0px 10px;"><input type="radio" id="computeArea" name="computeOption" value="area">
                      <label for="computeArea">Compute Areas</label></td></tr>
                      <tr><td style="border: none; padding: 0px 0px 0px 10px;"><input type="radio" id="computeQuantile" name="computeOption" value="percentile">
                      <label for="computeQuantile">Compute Quantiles</label></td></tr>
          
                    </table>
                  </div>
        
           
              
                  <div class="distDropDown">
                    <select id="distributionSelect">
                      <option value="normal">Normal</option>
                      <option value="exponential">Exponential</option>
                      <option value="beta">Beta</option>
                      <option value="gamma">Gamma</option>
                      <option value="uniform">Uniform</option>
                    </select>
                  </div>

                    

                <!-- Radio buttons for Compute Area and Compute Percentile options -->
               
            </div>
          <div class="argsContainer">
                    <!-- Table for Compute Area options -->
                      <table id="areaOptions" style="display: none; width: 75%; top: 50%; right: 50%;">
                        <tr>
                            <td style="border: none; padding: 0px 0px 0px 100px;"><input type="radio" id="greaterThan" name="areaOption" value="greaterThan" checked></td>
                            <td style="border: none; padding: 0px 0px 0px 0px;">Area <b>greater than</b></td>
                            <td style="border: none; padding: 0px 0px 0px 0px;"><input style="width: 80px" type="number" id="zScoreGreaterThan" step="0.1" value="0"></td>
                           <td style="border: none; padding: 0px 0px 0px 0px;"><span></span></td>
                           <td style="border: none; padding: 0px 0px 0px 0px;"><span></span></td>
                            <td style="border: none; padding: 0px 0px 0px 0px;">Area:</td>
                            <td style="border: none; padding: 0px 0px 0px 0px;"><span id="computedAreaGreaterThan"></span></td>
                        </tr>
    
                        <!-- Repeat the same pattern for other rows -->
                        <tr>
                            <td style="border: none; padding: 0px 0px 0px 100px;"><input type="radio" id="lessThan" name="areaOption" value="lessThan"></td>
                            <td style="border: none; padding: 0px 0px 0px 0px;">Area <b>less than</b> </td>
                            <td style="border: none; padding: 0px 0px 0px 0px;"><input style="width: 80px" type="number" id="zScoreLessThan" step="0.1" value="0"></td>
                           <td style="border: none; padding: 0px 0px 0px 0px;"><span ></span></td>
                           <td style="border: none; padding: 0px 0px 0px 0px;"><span ></span></td>
                            <td style="border: none; padding: 0px 0px 0px 0px;">Area:</td>
                            <td style="border: none; padding: 0px 0px 0px 0px;"><span id="computedAreaLessThan"></span></td>
                        </tr>
                        <!-- Repeat the same pattern for other rows -->
    
                        <tr>
                            <td style="border: none; padding: 0px 0px 0px 100px;">
                                <input type="radio" id="greaterThanB" name="areaOption" value="greaterThanB">
                            </td>
                            <td style="border: none; padding: 0px 0px 0px 0px;">Area <b>between</b></td>
                            <td style="border: none; padding: 0px 0px 0px 0px;">
                                <input style="width: 80px" type="number" id="zScoreGreaterThanB" step="0.1" value="0">
                            </td>
                            <td style="border: none; padding: 0px 0px 0px 0px;">and</td>
                            <td style="border: none; padding: 0px 0px 0px 0px;">
                                <input style="width: 80px" type="number" id="zScoreLessThanB" step="0.1" value="0">
                            </td>
                            <td style="border: none; padding: 0px 0px 0px 0px;">Area:</td>
                            <td style="border: none; padding: 0px 0px 0px 0px;">
                                <span id="computedAreaGreaterThanB"></span>
                            </td>
                        </tr>
                        <tr>
                            <td style="border: none; padding: 0px 0px 0px 100px;">
                                <input type="radio" id="lessThanT" name="areaOption" value="lessThanT">
                            </td>
                            <td style="border: none; padding: 0px 0px 0px 0px;">Area in <b>tails</b> less than</td>
                            <td style="border: none; padding: 0px 0px 0px 0px;">
                                <input style="width: 80px" type="number" id="zScoreLessThanT" step="0.1" value="0">
                            </td>
                            <td style="border: none; padding: 0px 0px 0px 0px;">or greater than</td>
                            <td style="border: none; padding: 0px 0px 0px 0px;">
                                <input style="width: 80px" type="number" id="zScoreGreaterThanT" step="0.1" value="0">
                            </td>
                            <td style="border: none; padding: 0px 0px 0px 0px;">Area:</td>
                            <td style="border: none; padding: 0px 0px 0px 0px;">
                                <span id="computedAreaLessThanT"></span>
                            </td>
                        </tr>
                          <!-- Add more rows for other options -->
                      </table>
    
    
    
    
    
                          <!-- Table for Compute Quantile options -->
                          <table id="quantileOptions" style="display: none; width: 75%;">
                            <tr>
                                <td style="border: none; padding: 0px 0px 0px 100px;"><input type="radio" id="greaterThan" name="quantileOption" value="greaterThan" checked></td>
                              <td style="border: none; padding: 0px 0px 0px 0px;"><input style="width: 80px" type="number" id="areaGreaterThan" step="0.1" value="0.5"></td>
                              <td style="border: none; padding: 0px 0px 0px 0px;">of area <b>above</b></td>
                                
                               <td style="border: none; padding: 0px 0px 0px 0px;"><span></span></td>
                               <td style="border: none; padding: 0px 0px 0px 0px;"><span></span></td>
                                <td style="border: none; padding: 0px 0px 0px 0px;">Quantile:</td>
                                <td style="border: none; padding: 0px 0px 0px 0px;"><span id="computedQuantileGreaterThan"></span></td>
                            </tr>
        
                            <!-- Repeat the same pattern for other rows -->
                            <tr>
                                <td style="border: none; padding: 0px 0px 0px 100px;"><input type="radio" id="lessThan" name="quantileOption" value="lessThan"></td>
                              <td style="border: none; padding: 0px 0px 0px 0px;"><input style="width: 80px" type="number" id="areaLessThan" step="0.1" value="0.5"></td>
                              <td style="border: none; padding: 0px 0px 0px 0px;">of area <b>below</b></td>
                                
                               <td style="border: none; padding: 0px 0px 0px 0px;"><span ></span></td>
                               <td style="border: none; padding: 0px 0px 0px 0px;"><span ></span></td>
                                <td style="border: none; padding: 0px 0px 0px 0px;">Quantile:</td>
                                <td style="border: none; padding: 0px 0px 0px 0px;"><span id="computedQuantileLessThan"></span></td>
                            </tr>
                            <!-- Repeat the same pattern for other rows -->
        
                            <tr>
                                <td style="border: none; padding: 0px 0px 0px 100px;">
                                    <input type="radio" id="greaterThanB" name="quantileOption" value="greaterThanB">
                                </td>
                              <td style="border: none; padding: 0px 0px 0px 0px;">
                                <input style="width: 80px" type="number" id="areaGreaterThanB" step="0.1" value="0.95"></td>
                              <td style="border: none; padding: 0px 0px 0px 0px;">of area <b>between</b></td>
                                
                                <td style="border: none; padding: 0px 0px 0px 0px;"><span ></span></td>
                                <td style="border: none; padding: 0px 0px 0px 0px;"><span ></span></td>
                                <td style="border: none; padding: 0px 0px 0px 0px;">Quantile:</td>
                                <td style="border: none; padding: 0px 0px 0px 0px;">
                                    <span id="computedQuantileGreaterThanB"></span> , <span id="computedQuantileGreaterThanB2"></span>
                                </td>
                            </tr>
        
                            <!-- Add more rows for other options -->
                          </table>
                    
          </div>
          <div class="graphContainer">
              <div class="chartContainer">
                  <div class="innerContainer">
                      <h3>Normal Distribution</h3>
                      <label for="meanInput">Mean:</label>
                      <input type="number" id="meanInput" step="0.1" value="0" style="width: 80px">
                      <label for="stdDevInput">Standard Deviation:</label>
                      <input type="number" id="stdDevInput" step="0.1" value="1" min="0.001" style="width: 80px">





                  </div>
                  <canvas id="myChartNorm" ></canvas>
              </div>

            
          </div>
      </div>

      <body1>
        
        

        
        <!-- Include jStat.js library -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jstat/1.7.1/jstat.min.js"></script>

        <script>
          // Function to compute area under the normal distribution curve
          function computeNormalDistributionArea(mean, stdDev, zScore) {
            // Using jStat library to compute the cumulative distribution function (CDF)
            return jStat.normal.cdf(zScore, mean, stdDev);
          }
          // Function to compute area under the normal distribution curve
          function computeNormalDistributionQuantile(mean, stdDev, area) {
            // Using jStat library to compute the cumulative distribution function (CDF)
            return jStat.normal.inv(area, mean, stdDev);
          }

          // Function to update all computed areas based on current mean and stdDev
          function updateAllComputedAreas() {
            // Get user inputs
            var mean = parseFloat(document.getElementById("meanInput").value);
            var stdDev = parseFloat(document.getElementById("stdDevInput").value);

            // Update computed areas for all radio button options
            var radioOptions = document.getElementsByName("areaOption");

            for (var i = 0; i < radioOptions.length; i++) {
              var selectedRadio = radioOptions[i].value;
              var computedAreaElement = document.getElementById("computedArea" + selectedRadio.charAt(0).toUpperCase() + selectedRadio.slice(1));

              if (computedAreaElement) {
                var zScore;
                var computedArea;

                // Handle special cases for "greaterThan" and "greaterThanOrEqual"
                if (selectedRadio === "greaterThan" || selectedRadio === "greaterThanOrEqual") {
                  zScore = parseFloat(document.getElementById("zScore" + selectedRadio.charAt(0).toUpperCase() + selectedRadio.slice(1)).value);
                  computedArea = computeNormalDistributionArea(mean, stdDev, zScore);

                  // Adjust the computed area for "greaterThan" and "greaterThanOrEqual" options
                  if (selectedRadio === "greaterThan" || selectedRadio === "greaterThanOrEqual") {
                    computedArea = 1 - computedArea;
                  }
                  
                }
                  // Handle special case for "greaterThanB"
                  else if (selectedRadio === "greaterThanB") {
                   
                    var zScoreGreaterThanB = parseFloat(document.getElementById("zScoreGreaterThanB").value);
                    var zScoreLessThanB = parseFloat(document.getElementById("zScoreLessThanB").value);

                    // Find the min and max values
                    var minZScore = Math.min(zScoreGreaterThanB, zScoreLessThanB);
                    var maxZScore = Math.max(zScoreGreaterThanB, zScoreLessThanB);

                    
                    computedArea = computeNormalDistributionArea(mean, stdDev, maxZScore) - computeNormalDistributionArea(mean, stdDev, minZScore);
                    computedAreaElement = document.getElementById("computedAreaGreaterThanB"); // Corrected ID
                    
                  }

                  // Handle special case for "lessThanT"
                  else if (selectedRadio === "lessThanT") {
                   
                    var zScoreLessThanT = parseFloat(document.getElementById("zScoreLessThanT").value);
                    var zScoreGreaterThanT = parseFloat(document.getElementById("zScoreGreaterThanT").value);

                    // Find the min and max values
                    var minZScore = Math.min(zScoreLessThanT, zScoreGreaterThanT);
                    var maxZScore = Math.max(zScoreLessThanT, zScoreGreaterThanT);

                    
                    computedArea = computeNormalDistributionArea(mean, stdDev, minZScore) + (1 - computeNormalDistributionArea(mean, stdDev, maxZScore));
                    computedAreaElement = document.getElementById("computedAreaLessThanT"); // Corrected ID
                  
                  }
                // Handle other cases
                else {
                  zScore = parseFloat(document.getElementById("zScore" + selectedRadio.charAt(0).toUpperCase() + selectedRadio.slice(1)).value);
                  computedArea = computeNormalDistributionArea(mean, stdDev, zScore);
                }

                computedAreaElement.textContent = computedArea.toFixed(4); // Adjust the decimal places as needed
              }
            }
          }

          // Attach event listeners to radio buttons
          var radioOptions = document.getElementsByName("areaOption");
          for (var i = 0; i < radioOptions.length; i++) {
            radioOptions[i].addEventListener("change", updateAllComputedAreas);
          }

          // Attach event listener to zScore input elements
          var zScoreInputs = document.querySelectorAll('[id^="zScore"]');
          for (var i = 0; i < zScoreInputs.length; i++) {
            zScoreInputs[i].addEventListener("input", updateAllComputedAreas);
          }

          // Attach event listener to mean and stdDev input elements
          var meanInput1 = document.getElementById("meanInput");
          var stdDevInput1 = document.getElementById("stdDevInput");

          meanInput1.addEventListener("input", updateAllComputedAreas);
          stdDevInput1.addEventListener("input", updateAllComputedAreas);

          // Initial update when the page loads
          updateAllComputedAreas();

          function updateAllComputedQuantiles() {
            // Get user inputs
            var mean = parseFloat(document.getElementById("meanInput").value);
            var stdDev = parseFloat(document.getElementById("stdDevInput").value);

            // Update computed areas for all radio button options
            var radioOptions = document.getElementsByName("quantileOption");

            for (var i = 0; i < radioOptions.length; i++) {
              var selectedRadio = radioOptions[i].value;
              var computedQuantileElement = document.getElementById("computedQuantile" + selectedRadio.charAt(0).toUpperCase() + selectedRadio.slice(1));
              var computedQuantileElement2 = document.getElementById("computedQuantile" + selectedRadio.charAt(0).toUpperCase() + selectedRadio.slice(1));

              if (computedQuantileElement) {
                var area;
                var computedQuantile;
                var computedQuantile2;

                // Handle special cases for "greaterThan" and "greaterThanOrEqual"
                if (selectedRadio === "greaterThan") {
                  area = parseFloat(document.getElementById("area" + selectedRadio.charAt(0).toUpperCase() + selectedRadio.slice(1)).value);
                  computedQuantile = computeNormalDistributionQuantile(mean, stdDev, 1-area);

                 

                }
                  // Handle special case for "greaterThanB"
                else if (selectedRadio === "greaterThanB") {
                    var areaGreaterThanB = parseFloat(document.getElementById("areaGreaterThanB").value);

                    // Find the min and max values
                    var minArea = (1 - areaGreaterThanB) / 2;
                    var maxArea = areaGreaterThanB + (1 - areaGreaterThanB) / 2;

                    computedQuantile = computeNormalDistributionQuantile(mean, stdDev, minArea);
                    computedQuantile2 = computeNormalDistributionQuantile(mean, stdDev, maxArea);

                    computedQuantileElement = document.getElementById("computedQuantileGreaterThanB");
                    computedQuantileElement2 = document.getElementById("computedQuantileGreaterThanB2"); // Corrected ID

                    computedQuantileElement.textContent = computedQuantile.toFixed(4);
                    computedQuantileElement2.textContent = computedQuantile2.toFixed(4);
                }

                  
                // Handle other cases
                else {
                  area = parseFloat(document.getElementById("area" + selectedRadio.charAt(0).toUpperCase() + selectedRadio.slice(1)).value);
                  computedQuantile = computeNormalDistributionQuantile(mean, stdDev, area);
                }

                computedQuantileElement.textContent = computedQuantile.toFixed(4); // Adjust the decimal places as needed
              }
            }
          }

          // Attach event listeners to radio buttons
          var radioOptions = document.getElementsByName("quantileOption");
          for (var i = 0; i < radioOptions.length; i++) {
            radioOptions[i].addEventListener("change", updateAllComputedQuantiles);
          }

          // Attach event listener to zScore input elements
          var areaInputs = document.querySelectorAll('[id^="area"]');
          for (var i = 0; i < areaInputs.length; i++) {
            areaInputs[i].addEventListener("input", updateAllComputedQuantiles);
          }

          // Attach event listener to mean and stdDev input elements
          var meanInput2 = document.getElementById("meanInput");
          var stdDevInput2 = document.getElementById("stdDevInput");

          meanInput2.addEventListener("input", updateAllComputedQuantiles);
          stdDevInput2.addEventListener("input", updateAllComputedQuantiles);

          // Initial update when the page loads
          updateAllComputedQuantiles();
        </script>







        <script>
            function createChartNorm() {
                const ctxNorm = document.getElementById('myChartNorm').getContext('2d');
                const myChartNorm = new Chart(ctxNorm, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Normal Distribution',
                            data: [],
                            borderColor: 'rgba(75, 192, 192, 1)',
                            fill: false,
                            pointRadius: [0]  // Hide default points
                        }, {
                            label: '95% Interval',
                            data: [],
                            borderColor: 'rgba(75, 192, 192, 1)',
                            fill: true,
                            pointRadius: [0]  // Hide default points
                        }]
                    },
                    options: {
                        scales: {
                            x: {
                                type: 'linear',
                                position: 'bottom'
                            },
                            y: {
                                type: 'linear',
                                position: 'left'
                            }
                        }
                    }
                });
                return myChartNorm;
            }

            // Create the chart instance
            const myChartNorm = createChartNorm();

            

            // Set up listeners for input changes
            meanInput.addEventListener('input', updateChartNorm);
            stdDevInput.addEventListener('input', updateChartNorm);

            // Initial chart creation (using default values)
            updateChartNorm();
        </script>
        <script>
          function normalDistribution(mu, sd, x) {
               return jStat.normal.pdf(x, mu, sd);
           }

           function generateSequenceNorm(mu, sd, numPoints) {
               const sequence = [];
               const lowerBound = mu - 4 * sd;
               const upperBound = mu + 4 * sd;
               const step = (upperBound - lowerBound) / (numPoints - 1);

               for (let i = 0; i < numPoints; i++) {
                   const value = lowerBound + i * step;
                   sequence.push(value);
               }

               return sequence;
           }

           function updateChartNorm() {
               const meanInput = document.getElementById('meanInput');
               const stdDevInput = document.getElementById('stdDevInput');

             const computeAreaRadio = document.getElementById('computeArea');
             const computeQuantileRadio = document.getElementById('computeQuantile');

             const areaOptionsTable = document.getElementById('areaOptions');
             const quantileOptionsTable = document.getElementById('quantileOptions');

             let mean = parseFloat(meanInput.value) || 0;
             let standardDeviation = Math.max(parseFloat(stdDevInput.value), 0.001) || 0.001;

             // Ensure that stdDev is not below 0.001
               standardDeviation = Math.max(standardDeviation, 0.001);

             // Check which radio button is selected
             if (computeAreaRadio.checked) {
                 // Compute Area option is selected
                 areaOptionsTable.style.display = 'table';  // Show the table of options
                 quantileOptionsTable.style.display = 'none';
                 // ... (your logic for computing area based on selected options and input values)
             } else if (computeQuantileRadio.checked){
                  // Hide the table if Compute Area is not selected
                  quantileOptionsTable.style.display = 'table';
                  areaOptionsTable.style.display = 'none';
                  // ... (your logic for other options)
              } else {
                 // Hide the table if Compute Area is not selected
                 areaOptionsTable.style.display = 'none';
                 quantileOptionsTable.style.display = 'none';
                 // ... (your logic for other options)
             }

               const generatedSequenceNorm = generateSequenceNorm(mean, standardDeviation, 1000);
               const distributionValuesNorm = generatedSequenceNorm.map(x => normalDistribution(mean, standardDeviation, x));

               const lowerPercentile = jStat.normal.inv(0.025, mean, standardDeviation);
               const upperPercentile = jStat.normal.inv(0.975, mean, standardDeviation);

               // Add points at 2.5th and 97.5th percentiles
               const confidenceIntervalPoints = [
                   { x: lowerPercentile, y: normalDistribution(mean, standardDeviation, lowerPercentile) },
                   { x: upperPercentile, y: normalDistribution(mean, standardDeviation, upperPercentile) }
               ];

               // Filter values between lowerPercentile and upperPercentile
               const valuesInRange = distributionValuesNorm.filter(value => value >= lowerPercentile && value <= upperPercentile);

               myChartNorm.data.labels = generatedSequenceNorm.map(x => x.toFixed(2));
               myChartNorm.data.datasets[0].data = distributionValuesNorm;
               myChartNorm.data.datasets[0].pointRadius = [0];  // Hide default points
               myChartNorm.data.datasets[0].pointBackgroundColor = ['red', 'red'];  // Color for confidence interval points
               myChartNorm.data.datasets[0].pointBorderColor = ['red', 'red'];  // Border color for confidence interval points
               myChartNorm.data.datasets[0].pointStyle = ['circle', 'circle'];  // Style for confidence interval points
               myChartNorm.data.datasets[1] = {
                   label: '95% Confidence Interval',
                   data: confidenceIntervalPoints,
                   pointRadius: [6, 6],  // Size of confidence interval points
                   pointBackgroundColor: ['red', 'red'],
                   pointBorderColor: ['red', 'red'],
                   pointStyle: ['circle', 'circle'],
                   showLine: false
               };
             myChartNorm.data.datasets[2] = {
                  label: 'Area',
                  data: confidenceIntervalPoints,
                  showLine: false
              };
             myChartNorm.data.datasets[3] = {
                 label: 'Area',
                 data: confidenceIntervalPoints,
                 showLine: false
             };

             // Get the selected radio button for area computation
             const selectedRadio = document.querySelector('input[name="areaOption"]:checked');
             const selectedRadioQ = document.querySelector('input[name="quantileOption"]:checked');
             
             // Get the zScore input values
             const zScoreInput = document.getElementById('zScoreGreaterThan');
             const zScore = parseFloat(zScoreInput.value) || 0;

             const zScore2Input = document.getElementById('zScoreLessThan');
             const zScore2 = parseFloat(zScore2Input.value) || 0;

             const zScoreGreaterThanBInput = document.getElementById('zScoreGreaterThanB');
             const zScoreGreaterThanB = parseFloat(zScoreGreaterThanBInput.value) || 0;

             const zScoreLessThanBInput = document.getElementById('zScoreLessThanB');
             const zScoreLessThanB = parseFloat(zScoreLessThanBInput.value) || 0;

             const zScoreLessThanTInput = document.getElementById('zScoreLessThanT');
             const zScoreLessThanT = parseFloat(zScoreLessThanTInput.value) || 0;

             const zScoreGreaterThanTInput = document.getElementById('zScoreGreaterThanT');
             const zScoreGreaterThanT = parseFloat(zScoreGreaterThanTInput.value) || 0;

             const quantileGreaterThanInput = document.getElementById('computedQuantileGreaterThan');
             const quantileGreaterThan = quantileGreaterThanInput.textConent || 0;

             const quantileLessThanInput = document.getElementById('computedQuantileLessThan');
             const quantileLessThan = quantileLessThanInput.textContent || 0;

             const quantileGreaterThanBInput = document.getElementById('computedQuantileGreaterThanB');
             const quantileGreaterThanB = quantileGreaterThanBInput.textContent || -1.96;

             const quantileGreaterThanB2Input = document.getElementById('computedQuantileGreaterThanB2');
             const quantileGreaterThanB2 = quantileGreaterThanB2Input.textContent || 1.96;
             
             

             // Compute lower and upper bounds based on the selected radio button
             let lowerBound, upperBound, lowerBound2, upperBound2;
                 if (computeAreaRadio.checked) {
                     if (selectedRadio) {
                         const radioValue = selectedRadio.value;
        
                         if (radioValue === 'greaterThan') {
                             lowerBound = zScore;
                             upperBound = Infinity;
                         } else if (radioValue === 'lessThan') {
                             lowerBound = -Infinity;
                             upperBound = zScore2;
                         } else if (radioValue === 'greaterThanB') {
                             lowerBound = zScoreGreaterThanB;
                             upperBound = zScoreLessThanB;
                         } else if (radioValue === 'lessThanT') {
                             lowerBound = -Infinity;
                             upperBound = zScoreLessThanT;
                           lowerBound2 = zScoreGreaterThanT;
                            upperBound2 = Infinity;
                         } else {
                             // Handle other cases as needed
                         }
                     }
    
                     // Create an array to store values to be plotted
                     const plottedValues = Array(generatedSequenceNorm.length).fill(null);
        
                     // Set values within the specified range
                     distributionValuesNorm.forEach((value, index) => {
                         const x = generatedSequenceNorm[index];
                         if ((x >= lowerBound && x <= upperBound) || (x >= lowerBound2 && x <= upperBound2)) {
                             plottedValues[index] = value;
                         }
                     });
                     
        
                     // Update the chart data
                     myChartNorm.data.labels = generatedSequenceNorm.map(x => x.toFixed(2));
                     myChartNorm.data.datasets[2].data = plottedValues.map((y, index) => ({ x: generatedSequenceNorm[index], y }));
                     myChartNorm.data.datasets[2].type = 'line'; // Change the type to 'line'
                     myChartNorm.data.datasets[2].fill = 'start'; // Enable fill from the start of the line
                     myChartNorm.data.datasets[2].borderWidth = 1; // Set borderWidth to 0 to hide the line
                 } else if (computeQuantileRadio.checked) {
                        if (selectedRadioQ) {
                            const radioValue = selectedRadioQ.value;
      
                            if (radioValue === 'greaterThan') {
                                lowerBound = quantileGreaterThanInput.textContent;
                                upperBound = Infinity;
                            } else if (radioValue === 'lessThan') {
                                lowerBound = -Infinity;
                                upperBound = quantileLessThanInput.textContent;
                            } else if (radioValue === 'greaterThanB') {
                                lowerBound = quantileGreaterThanBInput.textContent;
                                upperBound = quantileGreaterThanB2Input.textContent;
                            } else {
                                // Handle other cases as needed
                            }
                        }
      
                        // Create an array to store values to be plotted
                        const plottedValues = Array(generatedSequenceNorm.length).fill(null);
      
                        // Set values within the specified range
                        distributionValuesNorm.forEach((value, index) => {
                            const x = generatedSequenceNorm[index];
                            if ((x >= lowerBound && x <= upperBound)) {
                                plottedValues[index] = value;
                            }
                        });
      
      
                        // Update the chart data
                        myChartNorm.data.labels = generatedSequenceNorm.map(x => x.toFixed(2));
                        myChartNorm.data.datasets[3].data = plottedValues.map((y, index) => ({ x: generatedSequenceNorm[index], y }));
                        myChartNorm.data.datasets[3].type = 'line'; // Change the type to 'line'
                        myChartNorm.data.datasets[3].fill = 'start'; // Enable fill from the start of the line
                        myChartNorm.data.datasets[3].borderWidth = 1; // Set borderWidth to 0 to hide the line
                        
              } else {
                 // Handle other cases as needed
             }
             
               myChartNorm.update();
             }


          // Get the zScore input values
           const zScoreInput = document.getElementById('zScoreGreaterThan');
           const zScore = parseFloat(zScoreInput.value) || 0;

           const zScore2Input = document.getElementById('zScoreLessThan');
           const zScore2 = parseFloat(zScore2Input.value) || 0;

           const zScoreGreaterThanBInput = document.getElementById('zScoreGreaterThanB');
           const zScoreGreaterThanB = parseFloat(zScoreGreaterThanBInput.value) || 0;

           const zScoreLessThanBInput = document.getElementById('zScoreLessThanB');
           const zScoreLessThanB = parseFloat(zScoreLessThanBInput.value) || 0;

           const zScoreLessThanTInput = document.getElementById('zScoreLessThanT');
           const zScoreLessThanT = parseFloat(zScoreLessThanTInput.value) || 0;

           const zScoreGreaterThanTInput = document.getElementById('zScoreGreaterThanT');
           const zScoreGreaterThanT = parseFloat(zScoreGreaterThanTInput.value) || 0;

           const quantileGreaterThanInput = document.getElementById('computedQuantileGreaterThan');
           const quantileGreaterThan = quantileGreaterThanInput.textContent || 0;

           const quantileLessThanInput = document.getElementById('computedQuantileLessThan');
           const quantileLessThan = quantileLessThanInput.textContent || 0;

           const quantileGreaterThanBInput = document.getElementById('computedQuantileGreaterThanB');
           const quantileGreaterThanB = quantileGreaterThanBInput.textContent || -1.96;

           const quantileGreaterThanB2Input = document.getElementById('computedQuantileGreaterThanB2');
           const quantileGreaterThanB2 = quantileGreaterThanB2Input.textContent || 1.96;

           const areaLessThanInput = document.getElementById('areaLessThan');
           const areaLessThan = parseFloat(areaLessThanInput.value) || 0;

           const areaGreaterThanInput = document.getElementById('areaGreaterThan');
           const areaGreaterThan = parseFloat(areaGreaterThanInput.value) || -1.96;

           const areaGreaterThanBInput = document.getElementById('areaGreaterThanB');
           const areaGreaterThanB = parseFloat(areaGreaterThanBInput.value) || 1.96;
          
          // Add event listeners for zScore input changes
          zScoreInput.addEventListener('input', updateChartNorm);
          zScore2Input.addEventListener('input', updateChartNorm);
          zScoreGreaterThanBInput.addEventListener('input', updateChartNorm);
          zScoreLessThanBInput.addEventListener('input', updateChartNorm);
          zScoreLessThanTInput.addEventListener('input', updateChartNorm);
          zScoreGreaterThanTInput.addEventListener('input', updateChartNorm);

          quantileGreaterThanInput.addEventListener('change', updateChartNorm);
          quantileLessThanInput.addEventListener('change', updateChartNorm);
          quantileGreaterThanBInput.addEventListener('change', updateChartNorm);
          quantileGreaterThanB2Input.addEventListener('change', updateChartNorm);

          areaGreaterThanInput.addEventListener('input', updateChartNorm);
          areaLessThanInput.addEventListener('input', updateChartNorm);
          areaGreaterThanBInput.addEventListener('input', updateChartNorm);
          
          
           const meanInput = document.getElementById('meanInput');
           const stdDevInput = document.getElementById('stdDevInput');

           meanInput.addEventListener('input', updateChartNorm);
           stdDevInput.addEventListener('input', updateChartNorm);

          // Set up listeners for radio button changes
          document.getElementById('computeArea').addEventListener('change', updateChartNorm);
          document.getElementById('computeQuantile').addEventListener('change', updateChartNorm);

          // Set up listeners for area option changes
          document.querySelectorAll('input[name="areaOption"]').forEach(option => {
              option.addEventListener('change', updateChartNorm);
          });

          // Set up listeners for area option changes
          document.querySelectorAll('input[name="quantileOption"]').forEach(option => {
              option.addEventListener('change', updateChartNorm);
          });

           const generatedSequenceNorm = generateSequenceNorm(0, 1, 1000);
           const distributionValuesNorm = generatedSequenceNorm.map(x => normalDistribution(0, 1, x));

           const lowerPercentile = jStat.normal.inv(0.025, 0, 1);
           const upperPercentile = jStat.normal.inv(0.975, 0, 1);

           // Add points at 2.5th and 97.5th percentiles
           const confidenceIntervalPoints = [
               { x: lowerPercentile, y: normalDistribution(0, 1, lowerPercentile) },
               { x: upperPercentile, y: normalDistribution(0, 1, upperPercentile) }
           ];

           // Filter values between lowerPercentile and upperPercentile
           const valuesInRange = distributionValuesNorm.filter(value => value >= lowerPercentile && value <= upperPercentile);

          
           // Initial chart creation (using default values)
           updateChartNorm();


        </script>
      </body1>



    

      <body3>
        <div class="chartContainer">
          <div style="align-content: inline-flex;">
             <h3>Exponential Distribution</h3>
            <label for="expBetaInput">Beta (scale):</label>
            <input type="number" id="expBetaInput" step="0.1" value="1" min="0.001" style="width: 80px">
          </div>
          <canvas id="myChartExp"></canvas>
        </div>
      </body3>

      <body5>
        <div class="chartContainer">
          <div style="align-content: inline-flex;">
            <h3>Beta Distribution</h3>
            <label for="betaAlphaInput">Alpha:</label>
            <input type="number" id="betaAlphaInput" step="0.1" value="1" min="0.001" style="width: 80px">
            <label for="betaBetaInput">Beta:</label>
            <input type="number" id="betaBetaInput" step="0.1" value="1" min="0.001" style="width: 80px">
          </div>
          <canvas id="myChartBeta"></canvas>
        </div>
      </body5>

      <body4>
        <div class="chartContainer">
          <div style="align-content: inline-flex;">
             <h3>Gamma Distribution</h3>
            <label for="gamAlphaInput">Alpha:</label>
            <input type="number" id="gamAlphaInput" step="0.1" value="1" min="0.001" style="width: 80px">
            <label for="gamBetaInput">Beta (scale):</label>
            <input type="number" id="gamBetaInput" step="0.1" value="1" min="0.001" style="width: 80px">
          </div>
          <canvas id="myChartGam"></canvas>
        </div>
      </body4>

      <body6>
        <div class="chartContainer">
          <div style="align-content: inline-flex;">
             <h3>Uniform Distribution</h3>
            <label for="unifLowerInput">a:</label>
            <input type="number" id="unifLowerInput" step="0.1" value="0" style="width: 80px">
            <label for="unifUpperInput">b:</label>
            <input type="number" id="unifUpperInput" step="0.1" value="1" style="width: 80px">
          </div>
          <canvas id="myChartUnif"></canvas>
        </div>
      </body6>





























   {% endblock %}